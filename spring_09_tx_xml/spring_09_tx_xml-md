第一类丢失更新
两个事物更新相同数据，如果一个事物提交，另一个事物回滚，第一个事物的更新会被回滚

脏读
地隔热事物查询到第一个事物未提交的更新数据，第二个事物根据该数据执行，但第一个事物回滚，
第二个事物操作脏数据

幻读
一个事物查询到了另一个事物已经提交的新数据，导致多次查询数据不一致

不可重复读
一个书屋查询到另外一个事物已经修改的数据，导致多次查询数据不一致

第二类丢失更新
多个事物同事读取相同数据，并完成各自的事物提交，导致最后一个事物提交会覆盖前面所有事物对数据的改变


事务的传播特性
在一个事务方法中，调用了其他事务的方法，此时事务该如何传递，按照什规则传播。

情况一 需要尊重 遵从当前事务
REQUIRED: 必须存在一个事务，如果当前存在一个事务，则加入到该事务中，否则，新建一个事务，使用比较多的情况
SUPPORTS: 支持当前事务，如果当前存在事务，则是伊宁该事务，否则，以非事务形式运行。
MANDATORY: 必须要存在事务，如果当存在事务，就使用该事务，否则，非法的事物状态异常:IllegalTranactionStatusException

情况二 不遵从当前事务的
REQUIRES_NEW: 不管当前是否存在事务，都会新开启一个事务， 必须是一个新的事物，使用的也不叫多，
NOT_SUPPORTED： 以非事物方式执行，如果当前存在事务，把当前事务挂起
NEVER: 不支持事务，如果当前存在事务，跑出一个异常

情况三 寄生事务 外部事务、内部事务、嵌套事务
NESTED: 寄生事务，如果当前存在事务，则在内部事务内执行
如果当前不存在事务，则创建一个新的事物
寄生事务可以通过数据库savePoint来实现 寄生事务可以回滚的 但是他的回滚不影响外部事务，但是外部事务的回滚会影响寄生事务
